---
layout: post
title:      "Building My Sinatra Project - RunLogger"
date:       2020-04-05 21:10:49 -0400
permalink:  building_my_sinatra_project_-_runlogger
---

For my Sinatra project, I decided to build a website that would allow individual users to upload a log of their running/jogging/walking sessions. The project consists of just two models-- Users and Runs. Users are created with an email, username, and password. Runs are created with a date, duration (running time), distance, and an optional notes. To meet the project requirements, each User would be able to apply the CRUD actions (Create, Read, Update, Delete) to their Runs. The User class would have a 'has many' relationship to the Run class, and the Run class would have a 'belongs to' relationship with the User class. 

ActiveRecord does most of the heavy lifting in this project. It is responsible for storing the information to the database, retrieving that information, sets the model relationships, and validates the form data before attempting to save the information. The BCrypt gem is also used to hash passwords stored in the database and authenticates them when logging in. In addition to those gems, I use a couple helper methods in my routes to get current user and check the login/session status to limit user access when needed. For instance, a user that is already logged in would not be able to navigate to the sign up page or edit a run log that is not theirs.

Overall, I was a little more intimidated going into this project than I was for the Ruby CLI project. Due to some major life changes (thanks, corona), my pace through the module's lessons was more sporadic than I would have liked and made it hard for me to wrap my head around some of the concepts. However, tackling the project connected those dots for me. In fact, I look back over the route section code now (which is where most of my initial struggles were) and I wonder what made me have a hard time with it. It all looks so simple now that it's put together. 

Other than figuring out the logic of using helper methods and routes, my other major struggle was with the Run class. As I would quickly find out, picking a project that used dates and times might not have been the best choice for a novice. Normally, I could have just stored both as strings with no issues. However, I wanted to be able to sort/order the Runs by date and display the date in a normal, American MM/DD/YYYY format. My solution was to convert dates to epoch time, which would allow the to be ordered when queried and display them in my erb files with Time.at. I'm still not sure if that was the best approach or how hard it would make a more experienced programmer cringe, but it ended up working in the end. 

Since we had a break week directly after the project, I decided to use that time to make my project a little more fancy and gain some experience with Bootstrap. While I do have a bit of experience with HTML/CSS, it had been a while since I had used it and did not have any experience with Bootstrap prior. Getting the hang of Bootstrap wasn't too bad. I was able to achieve a nice, responsive layout and made some of the Run 'cards' dynamic depending on what type of Run it was. However, some of the ways I achieved that was more than a little hacky. For instance, to add a jogging icon and yellow border to a Run that had the pace of 'Jog', I simply named my icon and CSS class jog and called it with erb tags (Ex: class= "<%=@run.pace%>"). 

I also spent some time making the project a bit more useful by adding some new features. I added an instance method for Runs that would display a Run's average speed in MPH based on the given distance and time. Then, based on the average speed, I added four more instance methods that displayed what that speed would mean in a common race distance. For example, if a user ran at a pace of 6 MPH, that would translate to a 31 minute 5k time. So now, the website gives back data to the user they don't already know, which makes it way more useful than just a run diary.
